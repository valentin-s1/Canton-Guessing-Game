import streamlit as st
from streamlit_autorefresh import st_autorefresh
import random
import time
import pandas as pd
from Levenshtein import distance as levenshtein_distance

# ----- Load game data from Excel file (long format) -----
@st.cache_data
def load_hint_data(path="data_new_long_format.xlsx"):
    return pd.read_excel(path)

df = load_hint_data()
cantons = df["canton"].unique().tolist()

# ----- Leaderboard and state initialization -----
if "leaderboard" not in st.session_state:
    st.session_state.leaderboard = {}

if "rounds" not in st.session_state:
    st.session_state.update({
        "rounds": 0,
        "score": 0,
        "current_round": 0,
        "round_cantons": [],
        "current_difficulty": 10,
        "pending_score": 10,
        "current_question": None,
        "correct": False,
        "hints": [],
        "attempts_left": 2,
        "round_start_time": None,
        "round_finished": False,
        "reveal_message": "",
        "feedback_message": "",
        "username": "",
        "game_started": False
    })

# ----- Start Screen -----
if st.session_state.rounds == 0 and not st.session_state.game_started:
    st.title("\U0001F1E8\U0001F1ED Canton Guessing Game")

    with st.expander("ℹ️ Game Rules & How to Play"):
        st.markdown("""
        **Objective:** Guess the correct canton based on up to 10 hints.

        - Choose rounds and enter your name.
        - Hints start hard (10 pts) and get easier (-1 pt each time).
        - You get **2 guesses** per round and 45 seconds.
        - The game uses typo-tolerant guessing (Levenshtein distance).

        **Leaderboard:** Top 5 scores shown, overwrites by name.
        """)

    if st.session_state.leaderboard:
        st.subheader("\U0001F3C6 Leaderboard (Top 5)")
        for name, score in sorted(st.session_state.leaderboard.items(), key=lambda x: -x[1])[:5]:
            st.write(f"{name}: {score} points")

    rounds = st.radio("Choose number of rounds:", [4, 8, 12])
    if st.button("Continue"):
        st.session_state.rounds = rounds
        st.session_state.round_cantons = random.sample(cantons, rounds)
        st.rerun()

# ----- Username input -----
elif not st.session_state.game_started:
    st.title("Enter your name")
    name = st.text_input("Username:")
    if name and st.button("Start Game"):
        st.session_state.username = name
        st.session_state.game_started = True
        st.session_state.round_start_time = time.time()
        st.rerun()

# ----- Game Logic -----
elif st.session_state.current_round < st.session_state.rounds:
    if not st.session_state.round_finished:
        st_autorefresh(interval=1000, limit=45, key="auto_refresh")

    input_key = f"guess_input_{st.session_state.current_round}"
    if st.session_state.get("clear_guess", False):
        st.session_state[input_key] = ""
        st.session_state.clear_guess = False

    st.title(f"Round {st.session_state.current_round + 1} of {st.session_state.rounds}")
    st.write(f"Player: {st.session_state.username}")
    st.write(f"Score: {st.session_state.score}")
    st.write(f"Attempts left: {st.session_state.attempts_left}")

    remaining_time = max(0, int(45 - (time.time() - st.session_state.round_start_time)))
    st.write(f"⏳ Time remaining: {remaining_time} seconds")

    current_canton = st.session_state.round_cantons[st.session_state.current_round]

    if not st.session_state.round_finished and remaining_time == 0:
        st.session_state.feedback_message = "⏱️ Time's up!"
        st.session_state.round_finished = True
        st.session_state.reveal_message = f"The correct answer was: {current_canton}"

    if not st.session_state.hints and not st.session_state.round_finished:
        hint_rows = df[(df["canton"] == current_canton) & (df["difficulty"] == st.session_state.current_difficulty)]
        if not hint_rows.empty:
            row = hint_rows.sample(1).iloc[0]
            st.session_state.current_question = row
            st.session_state.hints.append(f"{row['type']}: {row['hint']}")

    st.subheader("Hints so far:")
    for hint in st.session_state.hints:
        st.write(f"- {hint}")

    if st.session_state.feedback_message:
        st.info(st.session_state.feedback_message)

    if not st.session_state.round_finished:
        col1, col2 = st.columns(2)

        with col1:
            guess = st.text_input("Your Guess:", key=input_key)
            if guess:
                guess_clean = guess.strip().lower()
                actual = current_canton.lower()
                if guess_clean == actual or levenshtein_distance(guess_clean, actual) <= 2:
                    st.session_state.feedback_message = f"✅ Correct! You earned {st.session_state.pending_score} points."
                    st.session_state.score += st.session_state.pending_score
                    st.session_state.round_finished = True
                    st.session_state.clear_guess = True
                    st.rerun()
                else:
                    st.session_state.attempts_left -= 1
                    st.session_state.clear_guess = True
                    if st.session_state.attempts_left == 0:
                        st.session_state.feedback_message = "❌ No attempts left."
                        st.session_state.round_finished = True
                        st.session_state.reveal_message = f"The correct answer was: {current_canton}"
                    else:
                        st.session_state.feedback_message = f"❌ Wrong guess. {st.session_state.attempts_left} attempt(s) left."
                    st.rerun()

        with col2:
            if st.button("Next Hint"):
                hint_found = False

                while st.session_state.current_difficulty > 1:
                    used_hints = set(st.session_state.hints)
                    available_hints = df[(df["canton"] == current_canton) & (df["difficulty"] == st.session_state.current_difficulty)]

                    unused_hints = available_hints[
                        ~available_hints.apply(lambda r: f"{r['type']}: {r['hint']}" in used_hints, axis=1)
                    ]

                    if not unused_hints.empty:
                        selected = unused_hints.sample(1).iloc[0]
                        st.session_state.current_question = selected
                        st.session_state.hints.append(f"{selected['type']}: {selected['hint']}")
                        st.session_state.pending_score = max(1, st.session_state.current_difficulty)
                        hint_found = True
                        st.rerun()
                        break

                    st.session_state.current_difficulty -= 1

                if not hint_found:
                    st.warning("No more hints available.")

    if st.session_state.round_finished:
        st.info(st.session_state.reveal_message)
        time.sleep(2)
        st.session_state.current_round += 1
        st.session_state.update({
            "current_difficulty": 10,
            "pending_score": 10,
            "current_question": None,
            "correct": False,
            "hints": [],
            "attempts_left": 2,
            "round_start_time": time.time(),
            "round_finished": False,
            "reveal_message": "",
            "clear_guess": True,
            "feedback_message": ""
        })
        st.rerun()

# ----- Game End -----
else:
    st.title("Game Over")
    final_score = st.session_state.score
    st.write(f"\U0001F389 Final Score: {final_score} / {st.session_state.rounds * 10}")

    name = st.session_state.username
    st.session_state.leaderboard[name] = max(final_score, st.session_state.leaderboard.get(name, 0))

    if st.button("Play Again"):
        leaderboard = st.session_state.leaderboard
        st.session_state.clear()
        st.session_state.leaderboard = leaderboard
        st.rerun()

# Run with: streamlit run game_Flamur_v3.py
